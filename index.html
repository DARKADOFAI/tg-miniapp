<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NeuroSkull - Ответ</title>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&family=Fira+Code&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        :root {
            --tg-bg: var(--tg-theme-bg-color, #121212);
            --tg-text: var(--tg-theme-text-color, #e0e0e0);
            --spoiler-bg: #3a3a3a;
            --blockquote-bg: #202020;
            --blockquote-border: #4a4a4a;
        }
        body { font-family: 'Inter', sans-serif; background-color: var(--tg-bg); color: var(--tg-text); padding: 20px 15px; margin: 0; line-height: 1.7; }
        #content { max-width: 800px; margin: 0 auto; }
        pre { background-color: #282c34; padding: 15px; border-radius: 8px; font-family: 'Fira Code', monospace; white-space: pre-wrap; word-wrap: break-word; }
        .error { color: #ff6b6b; border: 1px solid #ff6b6b; padding: 15px; border-radius: 8px; }
        blockquote { background-color: var(--blockquote-bg); border-left: 4px solid var(--blockquote-border); padding: 10px 20px; margin: 1.5em 10px; color: #d0d0d0; }
        blockquote p { margin: 0; }
        details { border-radius: 8px; margin: 1em 0; }
        details > summary { padding: 10px 15px; background-color: var(--spoiler-bg); border-radius: 8px; cursor: pointer; outline: none; font-weight: bold; }
        .spoiler-content { padding: 15px; border: 1px solid var(--spoiler-bg); border-top: none; border-bottom-left-radius: 8px; border-bottom-right-radius: 8px; }
        .katex-display { display: block; margin: 1em 0; text-align: center; overflow-x: auto; overflow-y: hidden; }
    </style>
</head>
<body>
    <div id="content"><p>⏳ Загрузка ответа...</p></div>

    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>
    
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            Telegram.WebApp.ready();
            const contentDiv = document.getElementById('content');

            // --- НАСТРОЙКА MARKED.JS ---
            const underlineExtension = {
                name: 'underline', level: 'inline', start(src) { return src.indexOf('++'); },
                tokenizer(src, tokens) { const rule = /^\+\+([^\+\n]+)\+\+/; const match = rule.exec(src); if (match) { return { type: 'underline', raw: match[0], text: this.lexer.inlineTokens(match[1].trim()) }; } },
                renderer(token) { return `<u>${this.parser.parseInline(token.text)}</u>`; }
            };
            
            // --- ИСПРАВЛЕНИЕ: Спойлер ---
            const spoilerExtension = {
                name: 'spoiler',
                level: 'inline',
                start(src) { return src.indexOf('||'); },
                tokenizer(src, tokens) {
                    // Используем нежадное совпадение, чтобы захватить все до следующего '||'
                    const rule = /^\|\|(.+?)\|\|/; 
                    const match = rule.exec(src);
                    if (match) {
                        return {
                            type: 'spoiler',
                            raw: match[0],
                            // Убираем .trim(), чтобы знаки препинания оставались внутри
                            text: this.lexer.inlineTokens(match[1]) 
                        };
                    }
                },
                renderer(token) {
                    return `<details><summary>Спойлер</summary><div class="spoiler-content">${this.parser.parseInline(token.text)}</div></details>`;
                }
            };

            marked.use({ extensions: [underlineExtension, spoilerExtension] });

            // --- ОСНОВНАЯ ЛОГИКА: ЗАГРУЗКА ДАННЫХ С СЕРВЕРА ---
            async function fetchResponse() {
                // --- ВАЖНО: ЗАМЕНИТЕ ЭТОТ URL НА ПУБЛИЧНЫЙ АДРЕС ВАШЕГО СЕРВЕРА ---
                const backendUrl = 'https://77.110.126.145:666/get_response'; 

                if (!Telegram.WebApp.initData) {
                     contentDiv.innerHTML = `<div class="error"><h3>Ошибка</h3><p>Не удалось получить данные для аутентификации (initData). Попробуйте перезапустить Mini App.</p></div>`;
                     console.error("Telegram.WebApp.initData is not available.");
                     return;
                }

                try {
                    const res = await fetch(backendUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ initData: Telegram.WebApp.initData })
                    });

                    if (!res.ok) {
                        const errorData = await res.json().catch(() => ({ detail: 'Не удалось получить текст ошибки от сервера.' }));
                        throw new Error(`Ошибка сервера: ${res.status} - ${errorData.detail || 'Без деталей'}`);
                    }

                    const data = await res.json();

                    if (data.markdown) {
                        // --- ИСПРАВЛЕНИЕ: KaTeX ---
                        // 1. Изолируем блоки с формулами перед обработкой Markdown
                        let markdownText = data.markdown;
                        const mathBlocks = [];
                        // Регулярное выражение для поиска блоков $$...$$ и замены их на плейсхолдеры
                        markdownText = markdownText.replace(/^\$\$\n?([\s\S]+?)\n?\$\$/gm, (match) => {
                            const placeholder = `<div>%%MATH_BLOCK_${mathBlocks.length}%%</div>`;
                            mathBlocks.push(match); // Сохраняем оригинальный блок с $$
                            return placeholder;
                        });

                        // 2. Обрабатываем Markdown с плейсхолдерами
                        contentDiv.innerHTML = marked.parse(markdownText, { gfm: true, breaks: true });

                        // 3. Возвращаем блоки с формулами на место плейсхолдеров
                        // Это нужно, чтобы marked.js не добавил <p> вокруг плейсхолдера
                        contentDiv.innerHTML = contentDiv.innerHTML.replace(/<div>%%MATH_BLOCK_(\d+)%%<\/div>/g, (match, index) => {
                            return mathBlocks[parseInt(index, 10)];
                        });

                        // 4. Теперь безопасно рендерим формулы с помощью KaTeX
                        renderMathInElement(contentDiv, {
                            delimiters: [
                                {left: '$$', right: '$$', display: true},
                                {left: '$', right: '$', display: false}
                            ],
                            ignoredTags: ["script", "noscript", "style", "textarea", "pre", "code"]
                        });

                        // 5. Применяем подсветку синтаксиса для блоков кода
                        document.querySelectorAll('pre code').forEach(hljs.highlightElement);

                    } else {
                         throw new Error("Ответ от сервера получен, но он не содержит необходимого поля 'markdown'.");
                    }

                } catch (e) {
                    contentDiv.innerHTML = `<div class="error"><h3>Ошибка при загрузке данных</h3><p>Не удалось связаться с сервером для получения ответа.</p><p style="font-size: 0.8em; color: #888;">Детали: ${e.message}</p></div>`;
                    console.error("Ошибка при получении данных с бэкенда:", e);
                }
            }

            fetchResponse();
            Telegram.WebApp.expand();
        });
    </script>
</body>
</html>
