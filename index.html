<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NeuroSkull - Ответ</title>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&family=Fira+Code&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
    <style>
        /* CSS-стили остаются без изменений */
        :root {
            --tg-theme-bg-color: #ffffff;
            --tg-theme-text-color: #000000;
            --tg-theme-link-color: #007aff;
            --tg-theme-button-color: #007aff;
            --tg-theme-button-text-color: #ffffff;
            --tg-theme-secondary-bg-color: #f2f2f7;
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --tg-theme-bg-color: #1c1c1d;
                --tg-theme-text-color: #ffffff;
                --tg-theme-link-color: #0a84ff;
                --tg-theme-button-color: #0a84ff;
                --tg-theme-button-text-color: #ffffff;
                --tg-theme-secondary-bg-color: #2c2c2e;
            }
        }

        body {
            background-color: var(--tg-theme-bg-color);
            color: var(--tg-theme-text-color);
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding: 15px;
            box-sizing: border-box;
            word-wrap: break-word;
        }
        #content {
            font-size: 16px;
            line-height: 1.6;
        }
        pre {
            position: relative;
            background-color: var(--tg-theme-secondary-bg-color);
            padding: 1em;
            border-radius: 8px;
            overflow-x: auto;
            font-family: 'Fira Code', monospace;
        }
        code {
            font-family: 'Fira Code', monospace;
        }
        .hljs {
            background: none !important;
        }
        blockquote {
            border-left: 3px solid var(--tg-theme-link-color);
            margin-left: 0;
            padding-left: 1em;
            color: gray;
        }
        .error {
            background-color: #ffdddd;
            color: #d8000c;
            border: 1px solid #d8000c;
            padding: 15px;
            border-radius: 8px;
        }
        details {
            border: 1px solid #ccc;
            border-radius: 4px;
            padding: .5em .5em 0;
            margin: 1em 0;
        }
        summary {
            font-weight: bold;
            margin: -.5em -.5em 0;
            padding: .5em;
            cursor: pointer;
        }
        details[open] {
            padding: .5em;
        }
        details[open] summary {
            border-bottom: 1px solid #ccc;
            margin-bottom: .5em;
        }
        .spoiler-content {
            margin-top: 1em;
        }
    </style>
</head>
<body>
    <div id="content"><p>⏳ Загрузка ответа...</p></div>

    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>
    
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            Telegram.WebApp.ready();
            const contentDiv = document.getElementById('content');

            // --- ИЗМЕНЕНИЕ НАЧАЛО: Обновленные расширения для Marked.js ---

            // Расширение для блочных формул KaTeX
            const katexBlockExtension = {
                name: 'katexBlock',
                level: 'block',
                start(src) { return src.indexOf('$$'); },
                tokenizer(src, tokens) {
                    const rule = /^\$\$([\s\S]+?)\$\$/;
                    const match = rule.exec(src);
                    if (match) {
                        return { type: 'katexBlock', raw: match[0], text: match[1].trim() };
                    }
                },
                renderer(token) {
                    // Возвращаем блок как есть, чтобы KaTeX мог его обработать.
                    // Оборачиваем в <p> для правильного блочного отображения.
                    return `<p>${token.raw}</p>`;
                }
            };

            // Расширение для инлайн-формул KaTeX
            const katexInlineExtension = {
                name: 'katexInline',
                level: 'inline',
                start(src) { return src.indexOf('$'); },
                tokenizer(src, tokens) {
                    const rule = /^\$([^\$\n]+?)\$/;
                    const match = rule.exec(src);
                    if (match) {
                        return { type: 'katexInline', raw: match[0], text: match[1].trim() };
                    }
                },
                renderer(token) {
                    // Возвращаем как есть для KaTeX auto-renderer
                    return token.raw;
                }
            };

            // Расширение для подчеркнутого текста
            const underlineExtension = {
                name: 'underline',
                level: 'inline',
                start(src) { return src.indexOf('++'); },
                tokenizer(src, tokens) {
                    const rule = /^\+\+([^\+\n]+)\+\+/;
                    const match = rule.exec(src);
                    if (match) { return { type: 'underline', raw: match[0], text: this.lexer.inlineTokens(match[1].trim()) }; }
                },
                renderer(token) { return `<u>${this.parser.parseInline(token.text)}</u>`; }
            };
            
            // ИСПРАВЛЕННОЕ расширение для спойлеров
            const spoilerExtension = {
                name: 'spoiler',
                level: 'inline',
                start(src) { return src.indexOf('||'); },
                tokenizer(src, tokens) {
                    // Нежадный (non-greedy) regex, чтобы захватить все до следующего '||'
                    const rule = /^\|\|([\s\S]+?)\|\|/;
                    const match = rule.exec(src);
                    if (match) {
                        return {
                            type: 'spoiler',
                            raw: match[0],
                            // НЕ используем .trim(), чтобы сохранить знаки препинания
                            text: this.lexer.inlineTokens(match[1])
                        };
                    }
                },
                renderer(token) { return `<details><summary>Спойлер</summary><div class="spoiler-content">${this.parser.parseInline(token.text)}</div></details>`; }
            };

            // Регистрируем все расширения. Порядок важен.
            marked.use({
                extensions: [katexBlockExtension, katexInlineExtension, underlineExtension, spoilerExtension]
            });
            
            // --- ИЗМЕНЕНИЕ КОНЕЦ ---


            try {
                const urlParams = new URLSearchParams(window.location.search);
                const dataFromUrl = urlParams.get('data');
                const isCompressed = urlParams.get('compressed') === 'true';

                if (!dataFromUrl) {
                    throw new Error("Параметр 'data' не найден в URL.");
                }
                
                let markdownText;
                
                const decodedData = decodeURIComponent(dataFromUrl);

                if (isCompressed) {
                    const binaryString = atob(decodedData.replace(/ /g, '+'));
                    const len = binaryString.length;
                    const bytes = new Uint8Array(len);
                    for (let i = 0; i < len; i++) {
                        bytes[i] = binaryString.charCodeAt(i);
                    }
                    markdownText = pako.inflate(bytes, { to: 'string' });
                } else {
                    const binaryString = atob(decodedData.replace(/ /g, '+'));
                    const len = binaryString.length;
                    const bytes = new Uint8Array(len);
                    for (let i = 0; i < len; i++) {
                        bytes[i] = binaryString.charCodeAt(i);
                    }
                    markdownText = new TextDecoder().decode(bytes);
                }
                
                // Рендерим полученный Markdown
                contentDiv.innerHTML = marked.parse(markdownText, { gfm: true, breaks: true });
                
                // Применяем рендеринг математических формул
                renderMathInElement(contentDiv, {
                    delimiters: [
                        {left: '$$', right: '$$', display: true},
                        {left: '$', right: '$', display: false}
                    ],
                    // Игнорируем теги, где KaTeX не должен работать
                    ignoredTags: ["script", "noscript", "style", "textarea", "pre", "code"]
                });

                // Применяем подсветку синтаксиса
                document.querySelectorAll('pre code').forEach(hljs.highlightElement);

            } catch (e) {
                contentDiv.innerHTML = `<div class="error"><h3>Ошибка обработки данных</h3><p>${e.message}</p></div>`;
                console.error("Ошибка Mini App:", e);
            }

            Telegram.WebApp.expand();
        });
    </script>
</body>
</html>
